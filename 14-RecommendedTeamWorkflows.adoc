## Recommended Team Workflows
ifdef::env-github[:outfilesuffix: .adoc]

\\[Dan]: So there are quite a few important things to address in this chapter before it's ready for review.
\\[Dan]: 1. Define what you mean by "Git team workflow". Is it just how team members should interact, how to make the most use of git for something, etc. By defining this, you're effectively giving the criteria to the reader on which your four workflows can be evaluated and compared so it's important that you do give this definition as clearly as possible.
\\[Dan]: 2. At the end of the chapter, wrap it up with a section that compares the four directly. Use a table to compare features, ease of use, what you can and can't do etc.
\\[Dan]: 3. For all four workflows, preface and annotate your four main diagrams as part of a scenario (example given for the first one), add numbers to so you can then relate the more abstract numbered steps you've written to the diagram more easily as well. Also check those steps. Some seem to be out of sync with the diagrams as you have them.
\\[Dan]: 4. It would be nice to have a hint where to find in the book the coverage of each command used in the workflow for quick reference.
\\[Dan]: 5. The pros and cons of each workflow would be better presented as a bulleted list I think.

In this chapter you will learn the two most popular Git workflows and two of my personal workflows:
\\[Dan]: As noted above, define what you mena by git workflow so you give some context to the rest of the chapter.
* How to use Git Flow to manage branching and merging in a project
* How to use GitHub Flow to manage branching and merging in a project
\\[Dan]: For the two above, "single or multiple release project?", Also, as there is no reabsing mentioned, does that mean they are tied to just one style of history maintenance?
* How to use Mike Flow Single to manage branching, rebasing and merging in a single release project
* How to use Mike Flow Multiple to manage branching, rebasing and merging in a multiple release project

### GitHub Flow
\\[Dan]: Don't care about which came first. Nor will the reader.
GitHub Flow is so named because it is the Git workflow that came out of the GitHub organization. It was first formally described in a blog post by Scott Chacon in 2011 at http://scottchacon.com/2011/08/31/github-flow.html.

\\[Dan]: Could you redefine master and feature branches please? 
GitHub Flow is made very simple because it essentially only involves two types of branches: feature branches and the `master` branch. All commits are made on feature branches and then merged to the `master` branch after review in a Pull Request. All commits to `master` are considered stable. Additionally, GitHub deploys all commits to the `master` branch to their production web servers.
\\[Dan]: COuld you put these basic features of github flow as a bulleted list please?
You can read more about GitHub Flow on GitHub's guide at https://guides.github.com/introduction/flow/index.html.

\\[Dan]: As mentioned above, and something Bert and I will have mentione dbefore, it's always a good idea to start with a concrete example rather than an abstract explanation as people can understand the former more easily than the latter. For example:

\\[Dan]: Let's take an example. Chris and Dave are working on two new features for their text editor - an asciidoc syntax highlighter and an asciidoc to XML converter. Figure 14-1 shows how they would follow github flow to create a branch for each of the features they are working on and then feedback it back into the master branch when the feature is complete. (See 14-Githubflow-Dan.png)


.GitHub Flow
[[github-flow-diagram]]
image::diagrams/14-GitHubFlow.png[]

Let's look at <<github-flow-diagram>> from top (the oldest commit) to the bottom (the newest commit):

1.  The initial commit to a repository is on the `master` branch and made with `git add` and `git commit`.
\\[Dan]: Do you actually need step 1 here or in the other workflow explanations? 
2.  A new feature is being developed so it is branched off the `master` branch with `git checkout -b`.
3.  Another feature is developed in parallel so it too is branched off the `master` branch with `git checkout -b`.
\\[Dan]: Why not merge 2 and 3? "Each new feature being developed is done so in parallel in their own branch from `master` using `git checkout -b <branchname>`
4.  Commits are made to both feature branches with `git commit`. They are pushed periodically with `git push`. Commits may be rewritten locally with `git rebase --interactive` or `git commit --amend` before being pushed but are never rewritten after being pushed so `git push --force` is never required.
\\[Dan]: It would be nice to have a hint where to find in the book the coverage of each command used here for quick reference.
5.  A feature branch is submitted for review in a pull request either through the GitHub web interface or with `gh pull-request`. If any changes are needed due to comments in the pull request they are committed. The pull request is automatically updated after new commits have been pushed to the remote branch. When the branch is ready it is merged to `master` with `git merge --no-ff` and deleted with `git branch --delete` and `git push --delete`.
6.  The remaining feature branch wants the changes from `master` so merges them with `git merge --no-ff`. This may be simply to make use of them in the branch or to resolve conflicts in the feature branch before they are merged into `master`.
\\[Dan]: "Wants"? How about "pulls in"? I'm sure plenty coders would rather not deal with other people's code. "Begrudgingly must acknowledge" is sometimes more the case :-)
7.  The remaining feature branch is submitted for review, merged and deleted.

#### Pros and Cons
GitHub Flow's beauty is in its simplicity. It is very easy to use with Git, GitHub's web interface and any Git graphical tools that support branching and merging. As everything ends up in the `master` branch there's little concern about commits getting lost. A branch is created, committed to, reviewed in a pull request, committed to again if necessary, merged and deleted. If a branch exists it is because it either hasn't been merged to `master` or because someone forgot to delete it. You can find out which easily with a `git merge`; Git will refuse to merge the same commit more than once.
\\[Dan]: Is it me or is this note about Git merge really important to make louder? Bold or as a callout?

As a large web application GitHub doesn't have versioned releases which are released to customers. Every commit to the `master` branch is deployed to the production servers as soon as it is made. This approach is known as _continuous deployment_. This approach works well for web applications but doesn't work so well for e.g. desktop application software that needs to be released to users and have them restart their application to update it. In this case because hotfixes cannot be pushed instantly it's important to do more stabilization. 
\\[Dan]: What do you mean by "to do more stabilization"?
Additionally, some pieces of software need to support multiple versions at once e.g. new stable versions of v1.0 and v2.0. GitHub Flow doesn't account for this case at all. These more advanced cases call for a more advanced workflow, such as Git Flow.

\\[Dan]: Any notes here about your experience of using github flow?

### Git Flow
Git Flow was probably the first formal Git branching and merging workflow to take off. In 2010 Vincent Driessen wrote a blog post describing a Git workflow he had been using for his software projects at http://nvie.com/posts/a-successful-git-branching-model/.
\\[Dan]: What are its aims and goals? What does it address? Multiple releases? Is it git's equivalent workflow for a standard CVS or SVN release workflow?
Git Flow involves five different types of branches:

* The `master` branch is used only for stable releases. Every commit to the `master` branch is tagged immediately. Commits are never made directly but are merged in from hotfix or release branches.
* The `develop` branch is a long-lived branch (i.e. it is never deleted). It is used for the bulk of daily development either through bugfix commits directly to it, feature, release or hotfix branch merges to it.
* Feature branches are branched off `develop` and are used for new feature development. When they are ready they are merged back into `develop`. They can be named anything.
* Release branches are used to stabilize a release. They are branched off `develop` and have bugfixes made to them and hotfixes merged into them. Bugfixes and hotfixes are merged back into the `develop` branch. They are named prefixed with `release-`.
* Hotfix branches are used for small fixes that need an immediate new release. They are merged into `master` (where they are immediately tagged) and into the current release branch if it exists or `develop` if it does not. They are named prefixed with `hotfix-`.

\\[Dan]: As with github flow, preface and use the diagram to illustrate a developer story. Then use the list to present the abstract version with typical commands.

Let's look at a diagram to help us understand Git Flow:

.Git Flow
[[git-flow-diagram]]
image::diagrams/14-GitFlow.png[]

Let's look at <<git-flow-diagram>> from top (the oldest commit) to the bottom (the newest commit):

1.  The initial commit to a repository is on the `develop` branch and made with `git add` and `git commit`.
2.  A release branch for the v1.x release series is branched off the `develop` branch with `git checkout -b`.
3.  A new feature is being developed so it is branched off the `develop` branch with `git checkout -b`.
4.  Another feature is developed in parallel so it too is branched off the `develop` branch with `git checkout -b`.
5.  Commits are made to the release branches with `git commit` for changes or fixes specific to a release but not applicable to other application development. For example, this may be changing a version number displayed in the application.
6.  Commits are made to both feature branches with `git commit`. They may pushed periodically with `git push` but typically to the developer's own remote repository rather than the main repository. Commits may be rewritten locally with `git rebase --interactive` or `git commit --amend` before being pushed but are never rewritten after being pushed so `git push --force` is never required.
7.  Commits are made to the `develop` branch for changes that are not significant enough to be feature branches and not needed on the release branches. For example, small tweaks to behavior of the application that are not fixes may be committed directly to the `develop` branch.
8.  A release branch is ready and merged to `master` with `git merge --no-ff`. It is not deleted but kept around indefinitely in case any more stable releases are needed from it. It is immediately tagged `v1.0` with `git tag` and pushed with `git push` and `git push --tags`.
9.  A new hotfix is needed for both the `develop` branch and a release branch so a hotfix branch is branched off the `develop` branch with `git checkout -b`.
10.  A hotfix branch is ready and merged to both `develop` and `master` with `git merge --no-ff` and deleted with `git branch --delete` and `git push --delete`. The new `master` branch is immediately tagged `v1.0` with `git tag` and pushed with `git push` and `git push --tags`.
11.  A feature branch is ready and merged to `master` with `git merge --no-ff` and deleted with `git branch --delete` and `git push --delete`. It is immediately tagged `v1.1` with `git tag` and pushed with `git push` and `git push --tags`.
12.  A new release branch for the v2.x release series is branched off the `develop` branch with `git checkout -b`.
13.  A release branch is ready and merged to `master` with `git merge --no-ff`. It is not deleted but kept around indefinitely in case any more stable releases are needed from it. It is immediately tagged `v2.0` with `git tag` and pushed with `git push` and `git push --tags`.
14.  A hotfix branch is ready and merged to both `develop` and `master` with `git merge --no-ff` and deleted with `git branch --delete` and `git push --delete`. The new `master` branch is immediately tagged `v2.1` with `git tag` and pushed with `git push` and `git push --tags`.

Git Flow also has a set of Git extensions which allow working through this workflow with some commands. For example, to create a new feature branch you can run `git flow feature start new-feature-name`. You can download these extensions and read more about them at https://github.com/nvie/gitflow.

#### Pros and Cons
//[Dan]: This actually reads like you're holding back your actual opinion of git flow. Throw in your experience here... don't hold back.
These different types of branches allow both flexibility and a formal release process. With the desktop application example we were talking about previously Git Flow allows a way of keeping track of released versions, features in development, urgent and non-urgent bug fixes through branch naming. Having a formal flow through which branches are merged means that a review process can ensure that things are reviewed multiple times before going into a release.

This formal process comes at a cost, however. As you can see from the above workflow and diagram it is quite complicated to get to grips with. This can work well for organizations where people can be trained and on-boarded but less well for short projects or open-source projects which seek to attract many new contributors. Also, if you are using continuous deployment the number of merges requires from feature branch to `master` branch can be be excessive.

### Mike Flow
I've used many different Git workflows over the years from Git Flow, GitHub Flow to the Homebrew's and CMake's workflows mentioned in <<13-MergingVsRebasing#homebrew-s-workflow>> and <<13-MergingVsRebasing#cmake-s-workflow>>. They all have their pros and cons but my preferred workflow is something I've named for this book _Mike Flow_.

As we've seen with GitHub Flow and Git Flow different release processes are optimized for continuously deployed web applications versus more slowly received desktop applications. For this reason _Mike Flow_ has two slighly different workflows: Mike Flow Single and Mike Flow Multiple.

The "Single" and "Multiple" in these cases refer to how many different versions of the software you need to support at once. Say you have made a `v1.5` release and a `v2.0` release. Will you make a `v1.6` release after `v2.0`? If not, you want Mike Flow Single and if so you want Mike Flow Multiple. If you're doing contiuous deployment that's OK too; Mike Flow Single can be used in this fashion too.

#### Mike Flow Single
Mike Flow Single is essentially GitHub Flow with two extra elements:

1.  Branches can (and should be) rebased, rewritten and squashed where appropriate (i.e. to make history cleaner but not if the branch is being used by multiple people).
2.  Stable releases can be tagged on the `master` branch.
\\[Dan]: As with github flow, preface and use the diagram to illustrate a developer story. Then use the list to present the abstract version with typical commands.

.Mike Flow Single
[[mike-flow-single-diagram]]
image::diagrams/14-MikeFlowSingle.png[]

Let's look at <<mike-flow-single-diagram>> from top (the oldest commit) to the bottom (the newest commit):

1.  The initial commit to a repository is on the `master` branch and made with `git add` and `git commit`.
2.  A new feature is being developed so it is branched off the `master` branch with `git checkout -b`.
3.  Another feature is developed in parallel so it too is branched off the `master` branch with `git checkout -b`.
4.  Commits are made to both feature branches with `git commit`. They are pushed periodically with `git push`.
5.  A feature branch is submitted for review in a pull request either through the GitHub web interface or with `gh pull-request`. If any changes \\[Dan]: changes to what?
are needed due to comments in the pull request they are committed. The pull request is automatically updated \\[Dan]:even if, say, a new file has been created?
 after new commits have been pushed to the remote branch. When the branch is ready it is merged to `master` with `git merge` and deleted with `git branch --delete` and `git push --delete`. \\[Dan] Why must you run both commands?
6.  The remaining feature branch wants the changes from `master` and to rewrite commits so is rebased and squashed on top of `master` with `git rebase --interactive`. This may be simply to make use of work from `master` in the branch, to resolve conflicts in the feature branch before they are merged into `master` or to cleanup commits by rewriting them. \\[Dan]: It sounds scary to rebase your branch - what happens if in your rebasing you get merge conflicts with the new code in your branch? Is that what the interactive rebase is for?
7.  The remaining feature branch is submitted for review, merged and deleted.

#### Mike Flow Multiple
Mike Flow Multiple is essentially Mike Flow Single with release branches:

* Release branches are branched off of `master` and can be committed to directly, cherry-picked or merged to from feature branches.
* Unlike feature branches release branches are never rewritten.
* Tags are created on feature branches rather than `master`.

\\[Dan]: As with github flow, preface and use the diagram to illustrate a developer story. Then use the list to present the abstract version with typical commands.

Let's look at a diagram to help us understand Mike Flow Multiple:

.Mike Flow Multiple
[[mike-flow-multiple-diagram]]
image::diagrams/14-MikeFlowMultiple.png[]

Let's look at <<mike-flow-multiple-diagram>> from top (the oldest commit) to the bottom (the newest commit):

\\[Dan]: The bullets don't seem to be in complete sync with the diagram?
1.  The initial commit to a repository is on the `master` branch and made with `git add` and `git commit`.
2.  A new feature is being developed so it is branched off the `master` branch with `git checkout -b`.
3.  A release branch for the v1.x release series is branched off the `master` branch with `git checkout -b`.
4.  Commits are made to both feature branches with `git commit`. They are pushed periodically with `git push`. \\[Dan]: to master?
\\[Dan]: I don't see how this is happening in the diagram?
5.  A feature branch is submitted for review in a pull request either through the GitHub web interface or with `gh pull-request`. If any changes are needed due to comments in the pull request they are committed. The pull request is automatically updated after new commits have been pushed to the remote branch. When the branch is ready it is merged to `master` with `git merge` and deleted with `git branch --delete` and `git push --delete`.
6.  Commits are made to the release branches with `git commit` for changes or fixes specific to a release but not applicable to other application development. For example, this may be changing a version number displayed in the application.
7.  Another feature or fix is developed so a new feature branch is branched off the `master` branch with `git checkout -b`.
8.  A feature branch is ready and merged to both `master` and the release branch for the v1.x release series with `git merge` and deleted with `git branch --delete` and `git push --delete`. The new `master` branch is tagged `v1.1` with `git tag` and pushed with `git push` and `git push --tags`. The release branch is not deleted but kept around indefinitely in case any more stable releases are needed from it.
9.  Another feature is developed so a new feature branch is branched off the `master` branch with `git checkout -b`.
10.  A new release branch for the v2.x release series is branched off the `master` branch with `git checkout -b`.
11.  A fix is needed for the v2.x release series a new feature branch is branched off the v2.x release branch with `git checkout -b`.
12.  The feature branch fix is ready and merged to the v2.x release series branch with `git merge` and deleted with `git branch --delete` and `git push --delete`. The new `master` branch is tagged `v2.1` with `git tag` and pushed with `git push` and `git push --tags`.
13.  The remaining feature branch wants the changes from `master` and to rewrite commits so is rebased and squashed on top of `master` with `git rebase --interactive`. This may be simply to make use of work from `master` in the branch, to resolve conflicts in the feature branch before they are merged into `master` or to cleanup commits by rewriting them.
14.  The remaining feature branch is submitted for review, merged and deleted.

#### Pros and Cons
The two variants of Mike Flow allow any developers not interacting with a release to behave as if they were using GitHub Flow. Those developers are more experienced with Git are empowered by being able to use more advanced history rewriting on remote branches. This allows them to keep their work shared and backed up but still make changes before it is merged. Tags and multiple release branches are optionally added because they are necessary with some forms of software development such as desktop applications where multiple versions need to be supported. Obviously I'm biased but I think it provides the best of both Git Flow and GitHub Flow; a stable release and review structure but without the complexity as strictly a mandated process.

The main disadvantage with Mike Flow is that it is not a know workflow outside of this book and people who have worked with me! That said, I have know many other projects to adopt a very similar process. The other disadvantage is that its flexibility in history rewriting and branching may make mistakes easier to happen.

It's worth reading through and trying to understand all the workflows above and in <<13-MergingVsRebasing#homebrew-s-workflow>> and <<13-MergingVsRebasing#cmake-s-workflow> before deciding on a workflow for your own team. Ask yourselves how many code reviews you need before releasing code to customers, whether your team has advanced or basic Git experience, whether you want to be more permissive or more prescriptive and just which one "feels" best. Ultimately any of the workflows discussed in this book will be better than no workflow at all. Remember that Git is a powerful tool and it should help you and your team be more productive and write better software. Good luck with it!
### Which workflow is for you?
\\[Dan]: You absolutely need to end this chapter with a recap and comparison of all four, and a suggestion on how to decide which to use, much as you did in the merging vs rebasing chapter. 
### Summary
In this chapter you hopefully learned:

* How to use GitHub Flow to use feature branches and `master` for continuous deployment
* How to use Git Flow to create a strict release, bugfix and feature development process
* How to use Mike Flow to have a simple workflow for non-release operations with the power of history rewriting
